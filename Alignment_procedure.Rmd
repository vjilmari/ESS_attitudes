---
title: "Alignment procedure"
output: 
  html_document: 
    keep_md: yes
    number_sections: yes
    toc: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparations

### Load packages

```{r}
library(sirt)
library(psych)
library(dplyr)
library(lavaan)
```

### Read data

```{r}
dat<-read.csv2("dat.no.miss.csv",stringsAsFactors = F)

# data for refugee attitudes
imm.vars<-c("gvrfgap.R","rfgfrpc","rfgbfml.R")

# standardization of the indicators (as suggested by Asparouhov & Muthen, 2014)
na.standardize<-function(var){
  (var-mean(var,na.rm=T))/sd(var,na.rm=T)
}

dat$imm.1.z<-na.standardize(dat$gvrfgap.R)
dat$imm.2.z<-na.standardize(dat$rfgfrpc)
dat$imm.3.z<-na.standardize(dat$rfgbfml.R)

imm.z.vars<-c("imm.1.z","imm.2.z","imm.3.z")

describe(dat[,imm.z.vars])
describeBy(dat[,imm.z.vars],group=dat[,"cntry"])

#exclude Hungary
dat.imm<-dat %>%
  filter(cntry!="HU") %>%
  dplyr::select(cntry,all_of(imm.z.vars))
#dat.imm<-na.omit(dat.imm)


dat$env.1.z<-na.standardize(dat$gvrfgap.R)
dat$env.2.z<-na.standardize(dat$rfgfrpc)
dat$env.3.z<-na.standardize(dat$rfgbfml.R)

env.z.vars<-c("env.1.z","env.2.z","env.3.z")

describe(dat[,env.z.vars])
describeBy(dat[,env.z.vars],group=dat[,"cntry"])

#exclude Hungary
dat.env<-dat %>%
  #filter(cntry!="HU") %>%
  dplyr::select(cntry,all_of(env.z.vars))
#dat.env<-na.omit(dat.env)


```


# Alignment for refugee attitudes

Approach by Fischer and Karl (2019)

### Configural models

```{r}
par.imm <- invariance_alignment_cfa_config(dat = dat.imm[,imm.z.vars],
                                       group = dat.imm[,"cntry"])
par.imm
```

For Lithuania, some of the estimates are very strange. Exclude Lihtuania and rerun.

```{r}
dat.imm<-dat %>%
  filter(cntry!="HU" & cntry!="LT") %>%
  dplyr::select(cntry,all_of(imm.z.vars))
```

```{r}
par.imm <- invariance_alignment_cfa_config(dat = dat.imm[,imm.z.vars],
                                       group = dat.imm[,"cntry"])
par.imm
```

Few loadings are Heywood-cases, but let's see if these will be an issue in the alignment approach as well.

The tolerance suggested by Robitzsch (2019) (0.4 for loadings and 0.2 for intercepts), could be too loose. Selected 0.2 for both. 

### Alignment

```{r}
mod1.imm <- invariance.alignment(lambda = par.imm$lambda,
                             nu =par.imm$nu,
                             align.scale = c(0.2, 0.4),
                             align.pow = c(.125, .125))

mod1.imm$es.invariance["R2",]
mod1.imm
```

Invariance in loadings is quite well captured by the alignment, in intercepts this is pooreer, but it doesn't matter for the application.

### Constraints

```{r}
cmod1.imm <-
  invariance_alignment_constraints(mod1.imm,
                                   lambda_parm_tol = 0.20,
                                   nu_parm_tol = 0.20) 
#.20/.20 seems to work with three removed countries
summary(cmod1.imm)
```

### Use the constraints to refit a CFA

Automize the model script rows by the DIF table of the constrain models. It appeared that the script does not deal with "-" signs, so recode those to capital letter

```{r}
assign.constraints<-function(data,prefix){
  for (i in 1:ncol(data)){
    uniques<-unique(data[,i])
    for (j in 1:nrow(data)){
      data[j,i]<-paste0(prefix,".",i,".",LETTERS[which(uniques==data[j,i])])
      
    }
    
  }
  return(data)
}

lambda.constr<-assign.constraints(
  data=data.frame(cmod1.imm$lambda_list$parm_dif),
  prefix="l")
lambda.constr

#lambda.names.imm.1.z<-paste0("l1.",round(lambda.constr[,1],3))
#lambda.names.imm.2.z<-paste0("l2.",round(lambda.constr[,2],3))
#lambda.names.imm.3.z<-paste0("l3.",round(lambda.constr[,3],3))

lambda.names.imm.1.z<-lambda.constr[,1]
lambda.names.imm.2.z<-lambda.constr[,2]
lambda.names.imm.3.z<-lambda.constr[,3]

nu.constr<-assign.constraints(
  data=data.frame(cmod1.imm$nu_list$parm_dif),
  prefix="n")
nu.constr


nu.names.imm.1.z<-nu.constr[,1]
nu.names.imm.2.z<-nu.constr[,2]
nu.names.imm.3.z<-nu.constr[,3]

imm.1.z.loads<-paste0("c(",paste0(lambda.names.imm.1.z,collapse=","),")*imm.1.z")
imm.2.z.loads<-paste0("c(",paste0(lambda.names.imm.2.z,collapse=","),")*imm.2.z")
imm.3.z.loads<-paste0("c(",paste0(lambda.names.imm.3.z,collapse=","),")*imm.3.z")

imm.loads<-paste0("F.imm=~",imm.1.z.loads," + ",imm.2.z.loads," + ",imm.3.z.loads)

imm.1.z.nu<-paste0("imm.1.z~c(",paste0(nu.names.imm.1.z,collapse=","),")*1")

imm.2.z.nu<-paste0("imm.2.z~c(",paste0(nu.names.imm.2.z,collapse=","),")*1")

imm.3.z.nu<-paste0("imm.3.z~c(",paste0(nu.names.imm.3.z,collapse=","),")*1")

F.imm.vars<-paste0("F.imm~~c(",paste0(paste0("v",1:nrow(lambda.constr)),collapse=","),")*F.imm")

F.imm.means<-paste0("F.imm~c(",paste0(paste0("m",1:nrow(lambda.constr)),collapse=","),")*1")

#SD constraint (product ==1)

F.imm.var.constr<-paste0("sqrt(",
       paste0(paste0("v",1:nrow(lambda.constr)),collapse="*"),
       ")==1")

#mean constraint (mean ==0)

F.imm.mean.constr<-paste0("(",
       paste0(paste0("m",1:nrow(lambda.constr)),collapse="+"),
       ")/",nrow(lambda.constr),"==0")

CFA.script.imm<-paste0(imm.loads,"\n",
                   imm.1.z.nu,"\n",
                   imm.2.z.nu,"\n",
                   imm.3.z.nu,"\n",
                   F.imm.vars,"\n",
                   F.imm.means,"\n",
                   F.imm.var.constr,"\n",
                   F.imm.mean.constr
                   )
CFA.script.imm



```

### Fit the refined model

```{r}
#remember to fit this to the final dataset that will be used at the end for the factor scores

#try to only constrain loadings and keep intercepts free
#they need to be coded manually

fit.ref.imm<-lavaan(model=CFA.script.imm,
             auto.var=T,
                auto.fix.first=F,
             #meanstructure=T,
             data=dat.imm,
             group=c("cntry"))
```

```{r}

fitMeasures(fit.ref.imm)
summary(fit.ref.imm)




parameterestimates(fit.ref.imm)[parameterestimates(fit.ref.imm)$label!="",]

parameterestimates(fit.ref.imm)[parameterestimates(fit.ref.imm)$label=="",]
table(parameterestimates(fit.ref.imm)$label)

table(parameterestimates(fit.ref.imm)[parameterestimates(fit.ref.imm)$label!="","label"])
```
