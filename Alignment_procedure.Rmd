---
title: "Alignment procedure"
output: 
  html_document: 
    keep_md: yes
    number_sections: yes
    toc: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparations

### Load packages

```{r}
library(sirt)

```

### Read data

```{r}
dat<-read.csv2("dat.no.miss.csv",stringsAsFactors = F)

# data for refugee attitudes
imm.vars<-c("gvrfgap.R","rfgfrpc","rfgbfml.R")

# standardization of the indicators (as suggested by Asparouhov & Muthen, 2014)
na.standardize<-function(var){
  (var-mean(var,na.rm=T))/sd(var,na.rm=T)
}

dat$imm.1.z<-na.standardize(dat$gvrfgap.R)
dat$imm.2.z<-na.standardize(dat$rfgfrpc)
dat$imm.3.z<-na.standardize(dat$rfgbfml.R)

imm.z.vars<-c("imm.1.z","imm.2.z","imm.3.z")

describe(dat[,imm.z.vars])
describeBy(dat[,imm.z.vars],group=dat[,"cntry"])

#exclude Hungary
dat.imm<-dat %>%
  filter(cntry!="HU") %>%
  dplyr::select(cntry,all_of(imm.z.vars))
#dat.imm<-na.omit(dat.imm)


dat$env.1.z<-na.standardize(dat$gvrfgap.R)
dat$env.2.z<-na.standardize(dat$rfgfrpc)
dat$env.3.z<-na.standardize(dat$rfgbfml.R)

env.z.vars<-c("env.1.z","env.2.z","env.3.z")

describe(dat[,env.z.vars])
describeBy(dat[,env.z.vars],group=dat[,"cntry"])

#exclude Hungary
dat.env<-dat %>%
  filter(cntry!="HU") %>%
  dplyr::select(cntry,all_of(env.z.vars))
#dat.env<-na.omit(dat.env)


```


# Alignment for refugee attitudes

Approach by Fischer and Karl (2019)

### Configural models

```{r}
par <- invariance_alignment_cfa_config(dat = dat.imm[,imm.z.vars],
                                       group = dat.imm[,"cntry"])
par
```

For Lithuania, some of the estimates are very strange. Exclude Lihtuania and rerun.

```{r}
dat.imm<-dat %>%
  filter(cntry!="HU" & cntry!="LT") %>%
  dplyr::select(cntry,all_of(imm.z.vars))
```

```{r}
par <- invariance_alignment_cfa_config(dat = dat.imm[,imm.z.vars],
                                       group = dat.imm[,"cntry"])
par
```

Few loadings are Heywood-cases, but let's see if these will be an issue in the alignment approach as well.

The tolerance suggested by Robitzsch (2019) (0.4 for loadings and 0.2 for intercepts), could be too loose. Put 0.2 for both. And 

### Alignment

```{r}
mod1 <- invariance.alignment(lambda = par$lambda,
                             nu =par$nu,
                             align.scale = c(0.2, 0.2),
                             align.pow = c(0.125, 0.125))

mod1$es.invariance["R2",]
mod1
```

Invariance in loadings is quite well captured by the alignment, in intercepts this is pooreer, but it doesn't matter for the application.

### Constraints

```{r}
cmod1 <-
  invariance_alignment_constraints(mod1,
                                   lambda_parm_tol = 0.2,
                                   nu_parm_tol = 0.2)
summary(cmod1)
```

### Use the constraints to refit a CFA

Automize the model script rows by the DIF table of the constrain models

```{r}
str(cmod1$lambda_list)
lambda.constr<-data.frame(cmod1$lambda_list$parm_dif)

round(lambda.constr,3)

lambda.names.imm.1.z<-paste0("l1.",round(lambda.constr[,1],3))
lambda.names.imm.2.z<-paste0("l2.",round(lambda.constr[,2],3))
lambda.names.imm.3.z<-paste0("l3.",round(lambda.constr[,3],3))

nu.constr<-data.frame(cmod1$nu_list$parm_dif)

nu.names.imm.1.z<-paste0("n1.",round(nu.constr[,1],3))
nu.names.imm.2.z<-paste0("n2.",round(nu.constr[,2],3))
nu.names.imm.3.z<-paste0("n3.",round(nu.constr[,3],3))

imm.1.z.loads<-paste0("c(",paste0(lambda.names.imm.1.z,collapse=","),")*imm.1.z")
imm.2.z.loads<-paste0("c(",paste0(lambda.names.imm.2.z,collapse=","),")*imm.2.z")
imm.3.z.loads<-paste0("c(",paste0(lambda.names.imm.3.z,collapse=","),")*imm.3.z")

imm.loads<-paste0("F.imm=~",imm.1.z.loads," + ",imm.2.z.loads," + ",imm.3.z.loads)

imm.1.z.nu<-paste0("imm.1.z~c(",paste0(nu.names.imm.1.z,collapse=","),")*1")

imm.2.z.nu<-paste0("imm.2.z~c(",paste0(nu.names.imm.2.z,collapse=","),")*1")

imm.3.z.nu<-paste0("imm.3.z~c(",paste0(nu.names.imm.3.z,collapse=","),")*1")

F.imm.vars<-paste0("F.imm~~c(",paste0(paste0("v",1:nrow(lambda.constr)),collapse=","),")*F.imm")

F.imm.means<-paste0("F.imm~c(",paste0(paste0("m",1:nrow(lambda.constr)),collapse=","),")*1")

#SD constraint (product ==1)



F.imm.var.constr<-paste0("sqrt(",
       paste0(paste0("v",1:nrow(lambda.constr)),collapse="*"),
       ")==1")

CFA.script<-paste0(imm.loads,"\n",
                   imm.1.z.nu,"\n",
                   imm.2.z.nu,"\n",
                   imm.3.z.nu,"\n",
                   F.imm.vars,"\n",
                   F.imm.means,"\n",
                   F.imm.var.constr
                   )
CFA.script
```

### Fit the refined model

```{r}
#remember to fit this to the final dataset that will be used

fit.ref<-lavaan(model=CFA.script,
             auto.var=T,
                auto.fix.first=F,
             data=dat.imm,
             group=c("cntry"),
             missing="fiml")
```

```{r}
fitMeasures(fit.ref)

summary(fit.ref)
parameterestimates(fit.ref)
```
